# Proxy Design Pattern (代理设计模式)

## 概述
为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象，
好处：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能

目标对象(被代理对象)包括：
- 远程对象
- 创建开销大的对象
- 需要安全控制的对象

种类（形式）
- 静态代理
- 动态代理 
  1. JDK代理(接口代理)
  2. Cglib代理(可以在内存动态的创建对象，而不需要实现接口)
  
### 静态代理
在使用时需要定义接口或者父类，被代理对象（即目标对象）与代理对象实现相同的接口或者是继承相同的父类

**具体要求**
1. 定义一个接口ISubject
2. 目标对象TargetSubject实现接口ISubject
3. 代理对象Proxy实现接口ISubject,即与目标对象实现相同的接口ISubject
4. 调用时通过调用代理对象的方法来调用目标对象

**特别提醒：**
代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法

**优点：**
在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展

**缺点：**
因为代理对象需要实现与目标对象一样的接口，所以会有很多代理类，一旦接口增加方法，目标对象与代理对象都要维护

### 动态代理

1. JDK代理
- 代理对象不需要实现接口，但是目标对象要实现接口，否则不能使用动态代理
- 代理对象的生成，是利用JDK的API,动态的在内存中构建代理对象
- 也叫接口代理

**JDK中生成代理对象的API**
- 代理类所在包：java.lang.reflect.Proxy
- JDK实现代理只需要使用newProxyInstance方法，该方法需要接收三个参数，完整写法：
```java
public class Proxy implements java.io.Serializable {    
    public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h){}
}
```

2. Cglib代理



## 问题或意图
意图：为其他对象提供一种代理以控制对这个对象的访问

## 情景

## 动机

## 解决方案

## 示例

## 结果情景


## 基本原理

## 相关模式

## 已知应用