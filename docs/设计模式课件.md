# 软件设计模式

------

设计模式是什么？

  解决方案
  反复出现的软件设计问题的解决方案
  经过实践检验的解决方案（最佳实践）

  经验的结晶
  是训练有素的设计师和软件工程师集体成功经验的结晶

  以易于理解且规范的格式记录了这些经过实践检验的解决方案，便形成了设计模式(Design Pattern)

------

 **核心思想：**
 将可重用的解决方案总结出来，并分门别类，从而指导设计，减少代码重复和优化体系结构。

 **益处** 
- 重用，避免代码重复冗余
- 优化体系结构
- 提升系统的可维护性和弹性
- 代码更加容易测试，利于测试驱动
- 为性能优化提供便利
- 增强代码可读性，便于团队交流

**著作**

《设计模式：可复用面向对象软件的基础》

  出版时间：1994年

  作者：Erich Gamma、Richard Helm、Ralph Johnson、 john Vlissides

  GoF（Gang of Four），中文名——四人组  


## 2.分类

1. 创建型设计模式(Creational patterns)

该类型模式是对对象实例化过程的抽象，它通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，
帮助我们更好地组织创建对象的代码。增强弹性，以应对在不同情况下创建和初始化对象的代码变更。

- 简单工厂模式(Simple factory)
- 工厂方法模式(Factory Method)
- 抽象工厂模式(Abstract Factory)
- 建造者模式(Builder)
- 原型模式(Prototype)
- 单例模式(Singleton)



2. 结构型设计模式(Structural patterns)

该类模式控制了应用程序较大部分之间的关系 。它将以不同的方式影响应用程序。允许在不重写代码或自定义代码的情况下创建系统，可以使系统具有增加的重复使用性和应用性能。
优化对象结构，使其职责分明、粒度合适，降低耦合。

- 适配器模式(Adapter)
- 桥接模式(Bridge)
- 组合模式(Composite)
- 装饰器模式(Decorator)
- 外观模式(Facade)
- 享元模式(Flyweight)
- 代理模式(Proxy)



3. 行为型模式(Behavioral patterns)

该类型模式可以影响一个系统的状态和行为流，通过优化状态和行为流转换和修改的方式，可以更好地定义对象间的协作关系，使复杂的程序流程变得清晰，简化，优化并提高应用程序的可维护性。

- 责任链模式(Chain Of Responsibility)
- 命令模式(Command)
- 解释器模式(Interpreter)
- 迭代器模式(Iterator)
- 中介者模式(Mediator)
- 备忘录模式(Memento)
- 观察者模式(Observer)
- 状态模式(State)
- 策略模式(Strategy)
- 模板方法模式(Template Method)
- 访问者模式(Visitor)




## 3.设计原则

1. 单一职责原则
2. 接口隔离原则
3. 依赖倒转原则
4. 里氏替换原则
5. 开闭原则
6. 迪米特法则
7. 合成复用原则（组合/聚合复用原则）




## 4.单例模式 (Singleton Design Pattern)

------

单例模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的模式。

------

**要点：**

- 某个类只能有一个实例
  
  实现方式，构造函数私有化

- 必须自行创建这个实例

  实现方式，提供一个该类的静态变量来保存这个唯一的实例

- 必须自行向整个系统提供这个实例
  
  实现方式，对外提供获取该实例对象的方式：
  1. 直接暴露
  2. 用静态变量的get方法获取
  

**分类**

  1. 饿汉式：直接创建对象，不管否需要这个对象，不存在线程安全问题，在类初始化的时候，直接new的对象，通过cinit方法
     1. 直接实例化（简洁直观）
     2. 枚举式（最简洁）
     3. 静态代码块（适合复杂实例化）
  2. 懒汉式：延迟创建对象
     1. 线程不安全（适用于单线程）
     2. 线程安全（适用于多线程）
        - 同步方法
        - 同步代码块
        - 双重检查
     3. 静态内部类形式（适用于多线程）

**使用场景**

需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象、
   工具类对象、频繁访问数据库或文件的对象（比如数据源，session工厂等）



**注意事项和细节说明**

- 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
 - 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new



## 5.代理模式 (Proxy Design Pattern)

------

为一个对象提供一个代理以控制对这个对象的访问。即通过代理对象访问目标对象。

让客户端与代理而非组件本身通信。

------

#### 背景

客户端需要访问另一个组件提供的服务。直接访问技术上说可行，但可能不是最佳的。

#### 问题

直接访问组件常常不是最佳的。

- 不想在客户端以硬编码方式指定组件的物理位置。
- 不受限制地直接访问组件可能效率低下甚至不安全，需要额外的访问或控制机制。

这种设计问题的解决方案必须平衡下述部分或全部作用力：

- 对客户端和组件来说，访问组件的方式必须高效、划算、安全。
- 对客户端来说，对组件的访问必须透明而简单。具体地说，调用行为和语法与调用直接访问的组件时一样。
- 客户端应深知访问远程服务可能带来的性能和财务开销。完全透明可能导致不同服务的成本差异变得模糊。

#### 解决方案

让客户端与代理而非组件本身通信。这个代理提供了组件的接口，但执行额外的预处理和后处理，如访问控制检查或创建原件的只读副本。

#### 结构

**原件（original）**实现了特定服务。这种服务可以是诸如返回或显示数据笔简单操作，也可以是复杂的数据检索函数或涉及其他组件的计算。原件通常包括：

- 远程组件
- 创建开销大的组件
- 需要安全控制的组件
- 需要额外处理的组件

**客户端**负责执行特定任务。为完成工作，客户端通过访问代理间接地调用原件的服务，且调用行为和语法与调用本地组件时相同。

**代理**提供与原件相同的接口，并确保客户端正常地访问原件。为此，代理维护着一个指向原件的引用。通常，原件和代理一一对应。

**抽象原件**提供了代理和原件实现的抽象。

下图说明了这些组件之间的关系：

![](..\src\main\java\com\smart\design\pattern\structure\proxy\docs\代理模式v2.png)



#### 实现

要实现Proxy模式，请采取下述步骤：

1. 找出与组件访问控制相关的所有职责，将这些职责交给代理实现。
2. 如果可以，用一个抽象基类或接口定义代理和原件都有的部分，并从这个抽象基类或接口实现代理和原件。
3. 实现代理的函数。
4. 让原件和客户端不再承担由代理承担的职责。
5. 在代理中包含一个指向原件的句柄，将代理与原件关联起来。这个句柄可以是指针、引用、地址、标识符、套接字、端口等。
6. 消除客户端与原件的直接关系，用客户端与代理的类似关系取而代之。

**示例（Java实现）**：

 **静态代理**，在使用时需要定义接口或者抽象类，被代理对象（即目标对象）与代理对象实现相同的接口或者是继承相同的抽象类。

**具体要求**

1. 定义一个接口IObject
2. 原始对象OriginalObject实现接口IObject
3. 代理对象Proxy实现接口IObject,即与目标对象实现相同的接口IObject
4. 为一个对象提供一个代理以控制对这个对象的访问。即通过代理对象访问原始对象。

**特别提醒：**
代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法

**优点：**
在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展

**缺点：**
因为代理对象需要实现与目标对象一样的接口，所以会有很多代理类，一旦接口增加方法，目标对象与代理对象都要维护



#### 变种

- JDK代理(接口代理)

- Cglib代理(可以在内存动态的创建对象，而不需要实现接口)

  

- 远程代理（Remote Proxy）,对客户端隐藏远程组件的网络地址和进程间通信协议。

- 保护代理（Protection Proxy）,保护组件免受未经授权的访问。

- 缓存代理（Cache Proxy）,让多个本地客户端共享远程组件返回的结果。

- 同步代理（Synchronization Proxy）同步对组件的并发访问。

- 计数代理（Counting Proxy）,防止无意间删除组件，收集使用统计信息。

- 虚拟代理（Firewall Proxy）,保护本地客户端，防止从外面直接访问它们。



1. JDK代理
- 代理对象不需要实现接口，但是目标对象要实现接口，否则不能使用JDK动态代理
- 代理对象的生成，是利用JDK的API,动态的在内存中构建代理对象
- 也叫接口代理

   **JDK中生成代理对象的API**

- 代理类所在包：java.lang.reflect.Proxy
- JDK实现代理只需要使用newProxyInstance方法，该方法需要接收三个参数，完整写法：
```java
public class Proxy implements java.io.Serializable {    
    public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h){}
}
```

2. Cglib代理


1. 静态代理和JDK代理都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象
子类来实现代理-这就是Cglib代理
2. Cglib代理也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也将Cglib代理归属到动态代理。
3. Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现java接口，它广泛的被许多AOP的框架使用，例如Spring AOP,实现方法拦截
4. 在AOP编程中如何选择代理模式：
- 目标对象需要实现接口，用JDK代理
- 目标对象不要要实现接口，用Cglib代理
5. Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类

步骤：
1. 引入Cglib的jar包
2. 在内存中动态构建了类，注意: 代理的类不能为final，否则报错 java.lang.IllegaArgumentException
3. 目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法

#### 已知应用



#### 效果

**优点：**

1. 可以在原件实现的基础上，增强额外的功能操作，即扩展目标对象的功能。
2. 效率更高，开销更低。
3. 将客户端与服务器组件位置分离。
4. 将管理代码与功能分离。

**缺点：**

1. 间接降低了效率
2. 

## 6.拓展

面向模式的软件架构设计

在软件架构设计这个更大的背景下利用模式

模式系统，包含一系列软件设计模式，并提供了如何在软件开发中实现、组合和使用这些模式的指南

- 包含的模式足够多

- 以统一的方式描述所有的模式

- 提示模式之间的各种关系

- 对模式进行组织

- 能够帮助打造软件系统（应指出如何使用和实现其中的模式）

- 能够不断的发展，紧跟技术发展步伐，适时修改既有模式，改进其描述，添加缺少模式，剔除过时模式

  


| 模式分类   | 架构模式                                       | 设计模式                                                     | 代码模式                      |
| ---------- | ---------------------------------------------- | ------------------------------------------------------------ | ----------------------------- |
| 基础架构   | Layers<br />Pipes and Filters<br />Blackboard  | Interpreter                                                  |                               |
| 分布式系统 | Broker<br />Pipes and Filters<br />Microkernel |                                                              |                               |
| 交互式系统 | MVC<br />MVVM<br />PAC                         |                                                              |                               |
| 可适应系统 | MicroKernel<br />Reflection                    |                                                              |                               |
| 创建       |                                                | Abstract Factory <br />Prototype<br />Builder                | Singleton<br />Factory Method |
| 结构分解   |                                                | Whole-Part<br />Composite                                    |                               |
| 工作组织   |                                                | Master-Slave<br />Chain of Responsibility<br />Command<br />Mediator |                               |
| 访问控制   |                                                | Proxy<br />Facade<br />Iterator                              |                               |
| 服务变更   |                                                | Bridge<br />Strategy<br />State                              | Template Method               |
| 服务扩展   |                                                | Decorator<br />Vistor                                        |                               |
| 管理       |                                                | Command Processor<br />View Handler<br />Memento             |                               |
| 适配       |                                                | Adapter                                                      |                               |
| 通信       |                                                | Publisher-Subscriber<br />Forwarder-Receiver<br />Client-Dispatcher-Server |                               |
| 资源管理   |                                                | Flyweight                                                    | Counted Pointer               |
| 事件处理   | Proactor<br />Reactor                          | Acceptor-Connector<br />Asynchronous Completion Token<br />Event Notification<br />Observer<br />Publisher-Subscriber |                               |
| 同步       | Object Synchronizer                            | Balking<br />Code Locking<br />Data Locking<br />Guarded Suspension<br />Double-Checked Locking Optimization<br />Reader/Writer Locking<br />Specific Notification<br />Strategized Locking<br />Thread-safe Interface | Scoped Locking                |
| 并发       | Half-Sync/Half-Async<br />Leader/Followers     | Active Object<br />Master-Slave<br />Monitor Object<br />Producer-Consumer<br />Scheduler<br />Two-Phase Termination<br />Thread-Specific Storage |                               |

#### 模式描述模板

- 名称

  模式名称和摘要。

- 别名

  模式的其他名称，如果有的话。

- 示例

  一个真实的示例，证明问题确实存在，对即将介绍的模式确实有需求。

  在整个模式的描述中，在必要或对大家有帮助的情况下，我们将通过这个示例来说明解决方案和实现。

- 背景

  模式可能适用的情形。

- 问题

  模式解决的问题，包括涉及的作用力。

- 解决方案

  模式背后的基本解决原则

- 结构

  详细说明模式的结构各个方面，包括参与组件CRC卡以及OTM类图。

- 动态

  通常是一些情景，描述了模式的运行阶段行为。如用对象消息序列图对情景做进一步说明

- 实现

  模式实现指南

  这些指南只是建议，并非永恒的规则。你应该根据需求调整实现：添加不同、额外或更详细的步骤，或调整步骤的顺序。

- 示例解答

  对解决方案、结构、动态和实现等部分未 涉及，但对解决示例问题至关重要的各个方面进行讨论。

- 变种

  简要地描述当前模式的变种

- 已知应用

  模式在既有系统中的应用

- 效果

  模式的优点及潜在的缺点

- 参见

  列举其它一些模式，它们要么解决了类似的问题，要么有助于改进当前模式
