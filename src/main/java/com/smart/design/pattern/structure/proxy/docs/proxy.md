# 代理模式 (Proxy Design Pattern)

## 概述
为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象，
好处：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能

目标对象(被代理对象)包括：
- 远程对象
- 创建开销大的对象
- 需要安全控制的对象

种类（形式）
- 静态代理
- 动态代理 
  1. JDK代理(接口代理)
  2. Cglib代理(可以在内存动态的创建对象，而不需要实现接口)
  
### 静态代理
在使用时需要定义接口或者父类，被代理对象（即目标对象）与代理对象实现相同的接口或者是继承相同的父类

**具体要求**
1. 定义一个接口IObject
2. 目标对象TargetObject实现接口IObject
3. 代理对象Proxy实现接口IObject,即与目标对象实现相同的接口IObject
4. 调用时通过调用代理对象的方法来调用目标对象

**特别提醒：**
代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法

**优点：**
在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展

**缺点：**
因为代理对象需要实现与目标对象一样的接口，所以会有很多代理类，一旦接口增加方法，目标对象与代理对象都要维护

### 动态代理

1. JDK代理
- 代理对象不需要实现接口，但是目标对象要实现接口，否则不能使用JDK动态代理
- 代理对象的生成，是利用JDK的API,动态的在内存中构建代理对象
- 也叫接口代理

**JDK中生成代理对象的API**
- 代理类所在包：java.lang.reflect.Proxy
- JDK实现代理只需要使用newProxyInstance方法，该方法需要接收三个参数，完整写法：
```java
public class Proxy implements java.io.Serializable {    
    public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h){}
}
```

2. Cglib代理
步骤：
1. 引入Cglib的jar包
2. 在内存中动态构建了类，注意: 代理的类不能为final，否则报错 java.lang.IllegaArgumentException
3. 目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法

1. 静态代理和JDK代理都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象
子类来实现代理-这就是Cglib代理
2. Cglib代理也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也将Cglib代理归属到动态代理。
3. Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现java接口，它广泛的被许多AOP的框架使用，例如Spring AOP,实现方法拦截
4. 在AOP编程中如何选择代理模式：
- 目标对象需要实现接口，用JDK代理
- 目标对象不要要实现接口，用Cglib代理
5. Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类


## 问题或意图
意图：为其他对象提供一种代理以控制对这个对象的访问

## 情景

## 动机

## 解决方案

## 示例

## 结果情景


## 基本原理

## 相关模式

## 已知应用