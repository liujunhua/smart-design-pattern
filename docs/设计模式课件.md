# 设计模式

## 1.概述
  在面向对象程序设计(OOP)过程中，我们经常会遇到很多重复出现的问题，总结解决这些问题的成功经验和最佳实践便形成了设计模式(Design Pattern)。

  其核心思想是将可重用的解决方案总结出来，并分门另类，从而指导设计，减少代码重复和优化体系结构。

  **益处**
- 重用，避免代码重复冗余
- 优化体系结构
- 提升系统的可维护性和弹性
- 代码更加容易测试，利于测试驱动
- 为性能优化提供便利
- 增强代码可读性，便于团队交流


## 2.分类

1. 创建型设计模式(Creational patterns)

该类型模式是对对象实例化过程的抽象，它通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，
帮助我们更好地组织创建对象的代码。增强弹性，以应对在不同情况下创建和初始化对象的代码变更。

- 简单工厂模式(Simple factory)
- 工厂方法模式(Factory Method)
- 抽象工厂模式(Abstract Factory)
- 建造者模式(Builder)
- 原型模式(Prototype)
- 单例模式(Singleton)

2. 结构型设计模式(Structural patterns)

该类模式控制了应用程序较大部分之间的关系 。它将以不同的方式影响应用程序。允许在不重写代码或自定义代码的情况下创建系统，可以使系统具有增加的重复使用性和应用性能。
优化对象结构，使其职责分明、粒度合适，降低耦合。

- 适配器模式(Adapter)
- 桥接模式(Bridge)
- 组合模式(Composite)
- 装饰器模式(Decorator)
- 外观模式(Facade)
- 享元模式(Flyweight)
- 代理模式(Proxy)

3. 行为型模式(Behavioral patterns)

该类型模式可以影响一个系统的状态和行为流，通过优化状态和行为流转换和修改的方式，可以更好地定义对象间的协作关系，使复杂的程序流程变得清晰，简化，优化并提高应用程序的可维护性。

- 责任链模式(Chain Of Responsibility)
- 命令模式(Command)
- 解释器模式(Interpreter)
- 迭代器模式(Iterator)
- 中介者模式(Mediator)
- 备忘录模式(Memento)
- 观察者模式(Observer)
- 状态模式(State)
- 策略模式(Strategy)
- 模板方法模式(Template Method)
- 访问者模式(Visitor)


## 3.设计原则

1. 单一职责原则

2. 接口隔离原则

3. 依赖倒转原则

4. 里氏替换原则

5. 开闭原则

6. 迪米特法则

7. 合成复用原则（组合/聚合复用原则）


## 4.单例模式 (Singleton Design Pattern)

### 概述
单例模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的模式。

**要点：**
- 某个类只能有一个实例
  
  实现方式，构造函数私有化

- 必须自行创建这个实例

  实现方式，提供一个该类的静态变量来保存这个唯一的实例

- 必须自行向整个系统提供这个实例
  
  实现方式，对外提供获取该实例对象的方式：
  1. 直接暴露
  2. 用静态变量的get方法获取
  

**分类**
  1. 饿汉式：直接创建对象，不管否需要这个对象，不存在线程安全问题，在类初始化的时候，直接new的对象，通过cinit方法
     1. 直接实例化（简洁直观）
     2. 枚举式（最简洁）
     3. 静态代码块（适合复杂实例化）
  2. 懒汉式：延迟创建对象
     1. 线程不安全（适用于单线程）
     2. 线程安全（适用于多线程）
        - 同步方法
        - 同步代码块
        - 双重检查
     3. 静态内部类形式（适用于多线程）

**使用场景**

需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象、
   工具类对象、频繁访问数据库或文件的对象（比如数据源，session工厂等）



**注意事项和细节说明**

- 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
 - 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new



## 5.代理模式 (Proxy Design Pattern)

### 概述
为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象，
好处：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能

目标对象(被代理对象)包括：
- 远程对象
- 创建开销大的对象
- 需要安全控制的对象

种类（形式）
- 静态代理
- 动态代理 
  1. JDK代理(接口代理)
  2. Cglib代理(可以在内存动态的创建对象，而不需要实现接口)
  
### 静态代理
在使用时需要定义接口或者父类，被代理对象（即目标对象）与代理对象实现相同的接口或者是继承相同的父类

**具体要求**
1. 定义一个接口IObject
2. 目标对象TargetObject实现接口IObject
3. 代理对象Proxy实现接口IObject,即与目标对象实现相同的接口IObject
4. 调用时通过调用代理对象的方法来调用目标对象

**特别提醒：**
代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法

**优点：**
在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展

**缺点：**
因为代理对象需要实现与目标对象一样的接口，所以会有很多代理类，一旦接口增加方法，目标对象与代理对象都要维护

### 动态代理

1. JDK代理
- 代理对象不需要实现接口，但是目标对象要实现接口，否则不能使用JDK动态代理
- 代理对象的生成，是利用JDK的API,动态的在内存中构建代理对象
- 也叫接口代理

**JDK中生成代理对象的API**
- 代理类所在包：java.lang.reflect.Proxy
- JDK实现代理只需要使用newProxyInstance方法，该方法需要接收三个参数，完整写法：
```java
public class Proxy implements java.io.Serializable {    
    public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h){}
}
```

2. Cglib代理

1. 静态代理和JDK代理都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象
子类来实现代理-这就是Cglib代理
2. Cglib代理也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也将Cglib代理归属到动态代理。
3. Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现java接口，它广泛的被许多AOP的框架使用，例如Spring AOP,实现方法拦截
4. 在AOP编程中如何选择代理模式：
- 目标对象需要实现接口，用JDK代理
- 目标对象不要要实现接口，用Cglib代理
5. Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类

步骤：
1. 引入Cglib的jar包
2. 在内存中动态构建了类，注意: 代理的类不能为final，否则报错 java.lang.IllegaArgumentException
3. 目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法





## 6.拓展