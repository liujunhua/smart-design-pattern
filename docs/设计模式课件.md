# 设计模式

## 1.概述
  设计模式是什么？

  解决方案
  反复出现的软件设计问题的解决方案
  经过实践检验的解决方案（最佳实践）

  经验的结晶
  是训练有素的设计师和软件工程师集体成功经验的结晶

  以易于理解且规范的格式记录了这些经过实践检验的解决方案，便形成了设计模式(Design Pattern)



 **核心思想：**
 将可重用的解决方案总结出来，并分门别类，从而指导设计，减少代码重复和优化体系结构。



 **益处** 
- 重用，避免代码重复冗余
- 优化体系结构
- 提升系统的可维护性和弹性
- 代码更加容易测试，利于测试驱动
- 为性能优化提供便利
- 增强代码可读性，便于团队交流



**著作**

《设计模式：可复用面向对象软件的基础》

  出版时间：1994年

  作者：Erich Gamma、Richard Helm、Ralph Johnson、 john Vlissides

  GoF（Gang of Four），中文名——四人组

  


## 2.分类

1. 创建型设计模式(Creational patterns)

该类型模式是对对象实例化过程的抽象，它通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，
帮助我们更好地组织创建对象的代码。增强弹性，以应对在不同情况下创建和初始化对象的代码变更。

- 简单工厂模式(Simple factory)
- 工厂方法模式(Factory Method)
- 抽象工厂模式(Abstract Factory)
- 建造者模式(Builder)
- 原型模式(Prototype)
- 单例模式(Singleton)



2. 结构型设计模式(Structural patterns)

该类模式控制了应用程序较大部分之间的关系 。它将以不同的方式影响应用程序。允许在不重写代码或自定义代码的情况下创建系统，可以使系统具有增加的重复使用性和应用性能。
优化对象结构，使其职责分明、粒度合适，降低耦合。

- 适配器模式(Adapter)
- 桥接模式(Bridge)
- 组合模式(Composite)
- 装饰器模式(Decorator)
- 外观模式(Facade)
- 享元模式(Flyweight)
- 代理模式(Proxy)



3. 行为型模式(Behavioral patterns)

该类型模式可以影响一个系统的状态和行为流，通过优化状态和行为流转换和修改的方式，可以更好地定义对象间的协作关系，使复杂的程序流程变得清晰，简化，优化并提高应用程序的可维护性。

- 责任链模式(Chain Of Responsibility)
- 命令模式(Command)
- 解释器模式(Interpreter)
- 迭代器模式(Iterator)
- 中介者模式(Mediator)
- 备忘录模式(Memento)
- 观察者模式(Observer)
- 状态模式(State)
- 策略模式(Strategy)
- 模板方法模式(Template Method)
- 访问者模式(Visitor)




## 3.设计原则

1. 单一职责原则
2. 接口隔离原则
3. 依赖倒转原则
4. 里氏替换原则
5. 开闭原则
6. 迪米特法则
7. 合成复用原则（组合/聚合复用原则）




## 4.单例模式 (Singleton Design Pattern)

### 概述
单例模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的模式。

**要点：**
- 某个类只能有一个实例
  
  实现方式，构造函数私有化

- 必须自行创建这个实例

  实现方式，提供一个该类的静态变量来保存这个唯一的实例

- 必须自行向整个系统提供这个实例
  
  实现方式，对外提供获取该实例对象的方式：
  1. 直接暴露
  2. 用静态变量的get方法获取
  

**分类**
  1. 饿汉式：直接创建对象，不管否需要这个对象，不存在线程安全问题，在类初始化的时候，直接new的对象，通过cinit方法
     1. 直接实例化（简洁直观）
     2. 枚举式（最简洁）
     3. 静态代码块（适合复杂实例化）
  2. 懒汉式：延迟创建对象
     1. 线程不安全（适用于单线程）
     2. 线程安全（适用于多线程）
        - 同步方法
        - 同步代码块
        - 双重检查
     3. 静态内部类形式（适用于多线程）

**使用场景**

需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象、
   工具类对象、频繁访问数据库或文件的对象（比如数据源，session工厂等）



**注意事项和细节说明**

- 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
 - 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new



## 5.代理模式 (Proxy Design Pattern)

### 概述
为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象，
好处：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能

目标对象(被代理对象)包括：
- 远程对象
- 创建开销大的对象
- 需要安全控制的对象

种类（形式）
- 静态代理
- 动态代理 
  1. JDK代理(接口代理)
  2. Cglib代理(可以在内存动态的创建对象，而不需要实现接口)
  
### 静态代理
在使用时需要定义接口或者父类，被代理对象（即目标对象）与代理对象实现相同的接口或者是继承相同的父类

**具体要求**
1. 定义一个接口IObject
2. 目标对象TargetObject实现接口IObject
3. 代理对象Proxy实现接口IObject,即与目标对象实现相同的接口IObject
4. 调用时通过调用代理对象的方法来调用目标对象

**特别提醒：**
代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法

**优点：**
在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展

**缺点：**
因为代理对象需要实现与目标对象一样的接口，所以会有很多代理类，一旦接口增加方法，目标对象与代理对象都要维护

### 动态代理

1. JDK代理
- 代理对象不需要实现接口，但是目标对象要实现接口，否则不能使用JDK动态代理
- 代理对象的生成，是利用JDK的API,动态的在内存中构建代理对象
- 也叫接口代理

**JDK中生成代理对象的API**
- 代理类所在包：java.lang.reflect.Proxy
- JDK实现代理只需要使用newProxyInstance方法，该方法需要接收三个参数，完整写法：
```java
public class Proxy implements java.io.Serializable {    
    public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h){}
}
```

2. Cglib代理

1. 静态代理和JDK代理都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象
子类来实现代理-这就是Cglib代理
2. Cglib代理也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也将Cglib代理归属到动态代理。
3. Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现java接口，它广泛的被许多AOP的框架使用，例如Spring AOP,实现方法拦截
4. 在AOP编程中如何选择代理模式：
- 目标对象需要实现接口，用JDK代理
- 目标对象不要要实现接口，用Cglib代理
5. Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类

步骤：
1. 引入Cglib的jar包
2. 在内存中动态构建了类，注意: 代理的类不能为final，否则报错 java.lang.IllegaArgumentException
3. 目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法



## 6.拓展

面向模式的软件架构

在软件架构这个更大的背景下利用模式

模式系统，包含一系列软件设计模式，并提供了如何在软件开发中实现、组合和使用这些模式的指南

- 包含的模式足够多

- 以统一的方式描述所有的模式

- 提示模式之间的各种关系

- 对模式进行组织

- 能够帮助打造软件系统（应指出如何使用和实现其中的模式）

- 能够不断的发展，紧跟技术发展步伐，适时修改既有模式，改进其描述，添加缺少模式，剔除过时模式

  

**模式描述模板**

- 名称

  模式名称和摘要。

- 别名

  模式的其他名称，如果有的话。

- 示例

  一个真实的示例，证明问题确实存在，对即将介绍的模式确实有需求。

  在整个模式的描述中，在必要或对大家有帮助的情况下，我们将通过这个示例来说明解决方案和实现。

- 背景

  模式可能适用的情形。

- 问题

  模式解决的问题，包括涉及的作用力。

- 解决方案

  模式背后的基本解决原则

- 结构

  详细说明模式的结构各个方面，包括参与组件CRC卡以及OTM类图。

- 动态

  通常是一些情景，描述了模式的运行阶段行为。如用对象消息序列图对情景做进一步说明

- 实现

  模式实现指南

  这些指南只是建议，并非永司的规则。你应该根据需求调整实现：添加不同、额外或更详细的步骤，或调整步骤的顺序。

- 示例解答

  对解决方案、结构、动态和实现等部分未 涉及，但对解决示例问题至关重要的各个方面进行讨论。

- 变种

  简要地描述当前模式的变种

- 已知应用

  模式在既有系统中的应用

- 效果

  模式的优点及潜在的缺点

- 参见

  列举其它一些模式，它们要么解决了类似的问题，要么有助于改进当前模式

- 

**模式分类**

|              | 架构模式                                       | 设计模式                                                     | 成例                          |
| ------------ | ---------------------------------------------- | ------------------------------------------------------------ | ----------------------------- |
| 众混沌到有序 | Layers<br />Pipes and Filters<br />Blackboard  | Interpreter                                                  |                               |
| 分布式系统   | Broker<br />Pipes and Filters<br />Microkernel |                                                              |                               |
| 交互式系统   | MVC<br />MVVM<br />PAC                         |                                                              |                               |
| 可适应系统   | MicroKernel<br />Reflection                    |                                                              |                               |
| 创建         |                                                | Abstract Factory <br />Prototype<br />Builder                | Singleton<br />Factory Method |
| 结构分解     |                                                | Whole-Part<br />Composite                                    |                               |
| 工作组织     |                                                | Master-Slave<br />Chain of Responsibility<br />Command<br />Mediator |                               |
| 访问控制     |                                                | Proxy<br />Facade<br />Iterator                              |                               |
| 服务变更     |                                                | Bridge<br />Strategy<br />State                              | Template Method               |
| 服务扩展     |                                                | Decorator<br />Vistor                                        |                               |
| 管理         |                                                | Command Processor<br />View Handler<br />Memento             |                               |
| 适配         |                                                | Adapter                                                      |                               |
| 通信         |                                                | Publisher-Subscriber<br />Forwarder-Receiver<br />Client-Dispatcher-Server |                               |
| 资源管理     |                                                | Flyweight                                                    | Counted Pointer               |

